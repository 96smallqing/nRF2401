C51 COMPILER V9.00   STC15NRFRE_2                                                          11/15/2018 21:18:15 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE STC15NRFRE_2
OBJECT MODULE PLACED IN STC15NRFre_2.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE STC15NRFre_2.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\oled;..\STC15NRFre;.\Ti
                    -me4;.\DHT11) DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //ÊµÑé¾§ÕñÎ»11.0592MHz£¬²¨ÌØÂÊÎ»9600
   2          #include "stc15w4k.h"
   3          #include "T4_Time.h"
   4          #include "oled.h"
   5          #include "T4_Time.h"
   6          #include <intrins.h>
   7          typedef unsigned char uchar;
   8          typedef unsigned char uint;
   9          
  10          /******************************STC15´®¿Ú1¶¨Ê±Æ÷1Ä£Ê½0¶¨Òå************************************/
  11          typedef unsigned char BYTE;
  12          typedef unsigned int WORD;
  13          
  14          #define FOSC 11059200L          //ÏµÍ³ÆµÂÊ
  15          #define BAUD 9600             //´®¿Ú²¨ÌØÂÊ
  16          
  17          #define NONE_PARITY     0       //ÎÞÐ£Ñé
  18          #define ODD_PARITY      1       //ÆæÐ£Ñé
  19          #define EVEN_PARITY     2       //Å¼Ð£Ñé
  20          #define MARK_PARITY     3       //±ê¼ÇÐ£Ñé
  21          #define SPACE_PARITY    4       //¿Õ°×Ð£Ñé
  22          
  23          #define PARITYBIT EVEN_PARITY   //¶¨ÒåÐ£ÑéÎ»
  24          
  25          #define S1_S0 0x40              //P_SW1.6
  26          #define S1_S1 0x80              //P_SW1.7
  27          bit busy;
  28          
  29          void SendData(BYTE dat);
  30          void SendString(char *s);
  31          
  32          //****************************************IO¶Ë¿Ú¶¨Òå***************************************
  33          
  34          sbit  MISO = P3^2;
  35          sbit  MOSI = P3^5;
  36          sbit  SCK  = P3^4;
  37          sbit  CE   = P3^6;
  38          sbit  CSN  = P3^7;
  39          sbit  IRQ  = P3^3;
  40          
  41          sbit led0 = P4^3;
  42          sbit led1 = P4^2;
  43          //sbit led2 = P4^1;
  44          sbit led3 = P4^0;
  45          
  46          //*********************************************NRF24L01*************************************
  47          #define TX_ADR_WIDTH    5    // 5 uints TX address width
  48          #define RX_ADR_WIDTH    5    // 5 uints RX address width
  49          #define TX_PLOAD_WIDTH  32  // 20 uints TX payload
  50          #define RX_PLOAD_WIDTH  32   // 20 uints TX payload
  51          uint const TX_ADDRESS[TX_ADR_WIDTH]= {0x01,0x01,0x01,0x01,0x01}; //±¾µØµØÖ·   0x01,0x01,0x01,0x01,0x01
  52          uint const RX_ADDRESS[RX_ADR_WIDTH]= {0x10,0x10,0x10,0x10,0x10}; //½ÓÊÕµØÖ·   0x10,0x10,0x10,0x10,0x10
  53          //***************************************NRF24L01¼Ä´æÆ÷Ö¸Áî***********************************************
             -********
C51 COMPILER V9.00   STC15NRFRE_2                                                          11/15/2018 21:18:15 PAGE 2   

  54          #define READ_REG        0x00   //¶ÁÅäÖÃ¼Ä´æÆ÷,µÍ5Î»Îª¼Ä´æÆ÷µØÖ·
  55          #define WRITE_REG       0x20  //Ð´ÅäÖÃ¼Ä´æÆ÷,µÍ5Î»Îª¼Ä´æÆ÷µØÖ·
  56          #define RD_RX_PLOAD     0x61   // ¶ÁÈ¡½ÓÊÕÊý¾ÝÖ¸Áî     ¶ÁRXÓÐÐ§Êý¾Ý,1~32×Ö½Ú
  57          #define WR_TX_PLOAD     0xA0   // Ð´´ý·¢Êý¾ÝÖ¸Áî     Ð´TXÓÐÐ§Êý¾Ý,1~32×Ö½Ú
  58          #define FLUSH_TX        0xE1  // ³åÏ´·¢ËÍ FIFOÖ¸Áî     Çå³ýTX FIFO¼Ä´æÆ÷.·¢ÉäÄ£Ê½ÏÂÓÃ
  59          #define FLUSH_RX        0xE2   // ³åÏ´½ÓÊÕ FIFOÖ¸Áî    Çå³ýRX FIFO¼Ä´æÆ÷.½ÓÊÕÄ£Ê½ÏÂÓÃ
  60          #define REUSE_TX_PL     0xE3   // ¶¨ÒåÖØ¸´×°ÔØÊý¾ÝÖ¸Áî  ÖØÐÂÊ¹ÓÃÉÏÒ»°üÊý¾Ý,CEÎª¸ß,Êý¾Ý°ü±»²»¶Ï·¢ËÍ.
  61          #define NOP             0xFF   // ±£Áô           ¿Õ²Ù×÷,¿ÉÒÔÓÃÀ´¶Á×´Ì¬¼Ä´æÆ÷
  62          //*************************************SPI(nRF24L01)¼Ä´æÆ÷µØÖ·********************************************
             -********
  63          #define CONFIG          0x00  // ÅäÖÃÊÕ·¢×´Ì¬£¬CRCÐ£ÑéÄ£Ê½ÒÔ¼°ÊÕ·¢×´Ì¬ÏìÓ¦·½Ê½
  64          #define EN_AA           0x01  // ×Ô¶¯Ó¦´ð¹¦ÄÜÉèÖÃ
  65          #define EN_RXADDR       0x02  // ¿ÉÓÃÐÅµÀÉèÖÃ
  66          #define SETUP_AW        0x03  // ÊÕ·¢µØÖ·¿í¶ÈÉèÖÃ
  67          #define SETUP_RETR      0x04  // ×Ô¶¯ÖØ·¢¹¦ÄÜÉèÖÃ
  68          #define RF_CH           0x05  // ¹¤×÷ÆµÂÊÉèÖÃ
  69          #define RF_SETUP        0x06  // ·¢ÉäËÙÂÊ¡¢¹¦ºÄ¹¦ÄÜÉèÖÃ   RF¼Ä´æÆ÷
  70          #define STATUS          0x07  // ×´Ì¬¼Ä´æÆ÷
  71          #define OBSERVE_TX      0x08  // ·¢ËÍ¼à²â¹¦ÄÜ
  72          #define CD              0x09  // µØÖ·¼ì²â              ÔØ²¨¼ì²â¼Ä´æÆ÷
  73          #define RX_ADDR_P0      0x0A  // ÆµµÀ0½ÓÊÕÊý¾ÝµØÖ·
  74          #define RX_ADDR_P1      0x0B  // ÆµµÀ1½ÓÊÕÊý¾ÝµØÖ·
  75          #define RX_ADDR_P2      0x0C  // ÆµµÀ2½ÓÊÕÊý¾ÝµØÖ·
  76          #define RX_ADDR_P3      0x0D  // ÆµµÀ3½ÓÊÕÊý¾ÝµØÖ·
  77          #define RX_ADDR_P4      0x0E  // ÆµµÀ4½ÓÊÕÊý¾ÝµØÖ·
  78          #define RX_ADDR_P5      0x0F  // ÆµµÀ5½ÓÊÕÊý¾ÝµØÖ·
  79          #define TX_ADDR         0x10  // ·¢ËÍµØÖ·¼Ä´æÆ÷
  80          #define RX_PW_P0        0x11  // ½ÓÊÕÆµµÀ0½ÓÊÕÊý¾Ý³¤¶È     (1~32×Ö½Ú)
  81          #define RX_PW_P1        0x12  // ½ÓÊÕÆµµÀ0½ÓÊÕÊý¾Ý³¤¶È
  82          #define RX_PW_P2        0x13  // ½ÓÊÕÆµµÀ0½ÓÊÕÊý¾Ý³¤¶È
  83          #define RX_PW_P3        0x14  // ½ÓÊÕÆµµÀ0½ÓÊÕÊý¾Ý³¤¶È
  84          #define RX_PW_P4        0x15  // ½ÓÊÕÆµµÀ0½ÓÊÕÊý¾Ý³¤¶È
  85          #define RX_PW_P5        0x16  // ½ÓÊÕÆµµÀ0½ÓÊÕÊý¾Ý³¤¶È
  86          #define FIFO_STATUS     0x17  // FIFOÕ»ÈëÕ»³ö×´Ì¬¼Ä´æÆ÷ÉèÖÃ
  87          //**************************************************************************************
  88          void Delay(unsigned int s);
  89          void inerDelay_us(unsigned char n);
  90          void init_NRF24L01(void);
  91          uint SPI_RW(uint uchar);
  92          uchar SPI_Read(uchar reg);
  93          void SetRX_Mode(void);
  94          uint SPI_RW_Reg(uchar reg, uchar value);
  95          uint SPI_Read_Buf(uchar reg, uchar *pBuf, uchar uchars);
  96          uint SPI_Write_Buf(uchar reg, uchar *pBuf, uchar uchars);
  97          unsigned char nRF24L01_RxPacket(unsigned char* rx_buf);
  98          void nRF24L01_TxPacket(unsigned char * tx_buf);
  99          
 100          uchar flag,a;
 101          
 102          //*****************************************³¤ÑÓÊ±*****************************************
 103          void Delay(unsigned int s)
 104          {
 105   1        unsigned int i;
 106   1        for(i=0; i<s; i++);
 107   1        for(i=0; i<s; i++);
 108   1      }
 109          //******************************************************************************************
 110          uint  bdata sta;   //×´Ì¬±êÖ¾
 111          sbit RX_DR =sta^6;     //ÅÐ¶ÏÊÇ·ñ½ÓÊÕµ½Êý¾Ý   ÈôÊÕµ½Êý¾Ý Ôò±»ÖÃ1
 112          sbit TX_DS =sta^5;
 113          sbit MAX_RT =sta^4;
 114          /******************************************************************************************
C51 COMPILER V9.00   STC15NRFRE_2                                                          11/15/2018 21:18:15 PAGE 3   

 115          /*ÑÓÊ±º¯Êý
 116          /******************************************************************************************/
 117          void inerDelay_us(unsigned char n)
 118          {
 119   1        for(;n>0;n--)
 120   1          _nop_();
 121   1      }
 122          //****************************************************************************************
 123          /*NRF24L01³õÊ¼»¯
 124          //***************************************************************************************/
 125          void init_NRF24L01(void)
 126          {
 127   1          inerDelay_us(100);
 128   1          CE=0;    // chip enable
 129   1          CSN=1;   // Spi disable
 130   1          SCK=0;   // Spi clock line init high
 131   1        SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);    // Ð´±¾µØµØÖ·
 132   1        SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, RX_ADDRESS, RX_ADR_WIDTH); // Ð´½ÓÊÕ¶ËµØÖ·
 133   1      
 134   1        SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);      //  ÆµµÀ0×Ô¶¯ ACKÓ¦´ðÔÊÐí½ûÖ¹
 135   1        SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);  //  ÔÊÐí½ÓÊÕµØÖ·Ö»ÓÐÆµµÀ0£¬Èç¹ûÐèÒª¶àÆµµÀ¿ÉÒÔ²Î¿¼Page21  
 136   1        
 137   1        SPI_RW_Reg(WRITE_REG + SETUP_AW, 0x02); // Setup address width=5 bytes    °²×°µØÖ·¿í¶È£½5×Ö½Ú
 138   1        SPI_RW_Reg(WRITE_REG + RF_CH, 0);        //   ÉèÖÃÐÅµÀ¹¤×÷Îª2.4GHZ£¬ÊÕ·¢±ØÐëÒ»ÖÂ
 139   1        SPI_RW_Reg(WRITE_REG + RX_PW_P0, RX_PLOAD_WIDTH); //ÉèÖÃ½ÓÊÕÊý¾Ý³¤¶È£¬±¾´ÎÉèÖÃÎª32×Ö½Ú
 140   1        SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);     //ÉèÖÃ·¢ÉäËÙÂÊÎª1MHZ£¬·¢Éä¹¦ÂÊÎª×î´óÖµ0dB
 141   1        SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);     // IRQÊÕ·¢Íê³ÉÖÐ¶ÏÏìÓ¦£¬16Î»CRC £¬Ö÷½ÓÊÕ
 142   1      }
 143          //****************************************************************************************
 144          /*NRF24L01·¢ËÍ³õÊ¼»¯
 145          //***************************************************************************************/
 146          void init_NRF24L01_Send(void)
 147          {
 148   1         /*
 149   1          Á½¸önrf24l01Í¨ÐÅ£¬ÐèÒªÂú×ã3¸öÌõ¼þÏàÍ¬£º
 150   1          1.ÆµµÀÏàÍ¬£¨ÉèÖÃÆµµÀ¼Ä´æÆ÷RF_CH£©
 151   1          2.µØÖ·ÏàÍ¬£¨ÉèÖÃTX_ADDRºÍRX_ADDR_P0ÏàÍ¬£©
 152   1          3.Ã¿´Î·¢ËÍ½ÓÊÕµÄ×Ö½ÚÊýÏàÍ¬£¨Èç¹ûÉèÖÃÁËÍ¨µÀµÄÓÐÐ§Êý¾Ý¿í¶ÈÎªn£¬ÄÇÃ´Ã¿´Î·¢ËÍµÄ×Ö½ÚÊýÒ²±ØÐëÎªn£¬µ±È»£¬n<=32£
             -©
 153   1        */
 154   1          inerDelay_us(100);
 155   1          CE=0;    // chip enable  Ð¾Æ¬Ê¹ÄÜ
 156   1          CSN=1;   // Spi disable  SPI½ûÓÃ
 157   1          SCK=0;   // Spi clock line init high   SPIÊ±ÖÓÏß
 158   1          IRQ=1;
 159   1          SPI_Write_Buf(WRITE_REG + TX_ADDR, RX_ADDRESS, TX_ADR_WIDTH);    // Ð´±¾µØµØÖ·     Óë½ÓÊÕ´úÂëµÄ½ÓÊÕ¶ËµØ
             -Ö·ÏàÍ¬
 160   1          SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, RX_ADR_WIDTH); // Ð´½ÓÊÕ¶ËµØÖ·
 161   1        
 162   1        //ÓÐÁËÒÔÏÂÕâÈý¸öÅäÖÃ£¬·¢ËÍ·½µÄÁ÷³Ì¾Í±ä³ÉÁË·¢ËÍ-´¥·¢ÖÐ¶Ï¡£ÕâÑù¾ÍÅ×¿ªÁË½ÓÊÕ·½£¬¿ÉÒÔ×¨ÐÄÈ¥µ÷ÊÔ·¢ËÍ
 163   1      //  SPI_RW_Reg(WRITE_REG + EN_AA, 0x00);                 // Ê§ÄÜÍ¨µÀ0×Ô¶¯Ó¦´ð
 164   1      //  SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x00);            // Ê§ÄÜ½ÓÊÕÍ¨µÀ0
 165   1      //  SPI_RW_Reg(WRITE_REG + SETUP_RETR, 0x00);          // Ê§ÄÜ×Ô¶¯ÖØ·¢
 166   1        
 167   1        //ÒÔÉÏÈý¾äÖ»ÊÇµ÷ÊÔ·½·¨£¬×îÖÕµÄ²úÆ·Èç¹û²»¼ÓÉÏÓ¦´ðºÍÖØ·¢µÄ»°ÄÇÃ´Êý¾ÝµÄÎÈ¶¨ÐÔÊÇºÜÄÑ±£Ö¤µÄ£¬ËùÒÔÔÚ»ù±¾µÄÍ¨Ñ¶½
             -¨Á¢Ö®ºó¾ÍÒª°Ñ·¢ËÍµÄÅäÖÃ¸ÄÎªÒÔÏÂÕâÈý¸öÅäÖÃ 
 168   1        //ÕâÑù·¢ËÍºÍ½ÓÊÕ¾Í½øÈëÁËÒ»¸ö±ê×¼×´Ì¬£¬·¢ËÍ-µÈÓ¦´ð-£¨×Ô¶¯ÖØ·¢£©-´¥·¢ÖÐ¶Ï£»½ÓÊÕ-Ó¦´ð-´¥·¢ÖÐ¶Ï£¬Ò»ÇÐ°´²¿¾Í°à
             -£¬³ÌÐòÀï¼ÓÉÏ×Ô¼ºµÄÓ¦ÓÃ²¿·Ö¾ÍÄÜÊµÏÖºÜ¶à¹¦ÄÜÁË
 169   1          SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);               // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0×Ô¶¯Ó¦´ð
 170   1          SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);           // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0               
 171   1          SPI_RW_Reg(WRITE_REG + SETUP_RETR, 0x1a);          // ×Ô¶¯ÖØ·¢10´Î£¬¼ä¸ô500us
 172   1        
C51 COMPILER V9.00   STC15NRFRE_2                                                          11/15/2018 21:18:15 PAGE 4   

 173   1          SPI_RW_Reg(WRITE_REG + SETUP_AW, 0x02); // Setup address width=5 bytes  °²×°µØÖ·¿í¶È£½5×Ö½Ú   
 174   1          SPI_RW_Reg(WRITE_REG + RF_CH, 0);             //ÉèÖÃÐÅµÀ¹¤×÷Îª2.4GHZ£¬ÊÕ·¢±ØÐëÒ»ÖÂ
 175   1          SPI_RW_Reg(WRITE_REG + RX_PW_P0, TX_PLOAD_WIDTH);   //ÉèÖÃ½ÓÊÕÊý¾Ý³¤¶È£¬±¾´ÎÉèÖÃÎª32×Ö½Ú
 176   1          SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);         //ÉèÖÃ·¢ÉäËÙÂÊÎª2MHZ£¬·¢Éä¹¦ÂÊÎª×î´óÖµ0dB
 177   1          SPI_RW_Reg(WRITE_REG + CONFIG, 0x0e);           // IRQÊÕ·¢Íê³ÉÖÐ¶ÏÏìÓ¦£¬16Î»CRC£¬·¢ÉäÄ£Ê½
 178   1      }
 179          /****************************************************************************************************
 180          /*º¯Êý£ºuint SPI_RW(uint uchar)
 181          /*¹¦ÄÜ£ºNRF24L01µÄSPIÐ´Ê±Ðò
 182          /****************************************************************************************************/
 183          uint SPI_RW(uint uchar)
 184          {
 185   1      uint bit_ctr;
 186   1          for(bit_ctr=0;bit_ctr<8;bit_ctr++) // output 8-bit
 187   1          {
 188   2            MOSI = (uchar & 0x80);         // output 'uchar', MSB to MOSI   Êä³ö¡°uchar¡±£¬MSBµ½MOSI
 189   2            uchar = (uchar << 1);           // shift next bit into MSB..    ½«ÏÂÒ»Î»ÒÆµ½MSB
 190   2            SCK = 1;                      // Set SCK high..         ÉèÖÃSCK¸ß¡£
 191   2            uchar |= MISO;           // capture current MISO bit        »ñÈ¡µ±Ç° MISO bit
 192   2            SCK = 0;                // ..then set SCK low again       È»ºóÔÙ´ÎÉèÖÃSCKµÍµçÆ½
 193   2          }
 194   1          return(uchar);               // return read uchar           ·µ»Ø¶ÁÈ¡uchar
 195   1      }
 196          /****************************************************************************************************
 197          /*º¯Êý£ºuchar SPI_Read(uchar reg)
 198          /*¹¦ÄÜ£ºNRF24L01µÄSPIÊ±Ðò
 199          /****************************************************************************************************/
 200          uchar SPI_Read(uchar reg)
 201          {
 202   1        uchar reg_val;
 203   1        
 204   1        CSN = 0;                // CSN low, initialize SPI communication... CSNµÍ£¬³õÊ¼»¯SPIÍ¨ÐÅ
 205   1        SPI_RW(reg);            // Select register to read from..     Ð´¼Ä´æÆ÷µØÖ·  Ñ¡Ôñ¼Ä´æÆ÷¶ÁÈ¡
 206   1        reg_val = SPI_RW(0);    // ..then read registervalue        È»ºó¶ÁÈ¡×¢²áÖµ Ð´Èë¶Á¼Ä´æÆ÷Ö¸Áî
 207   1        CSN = 1;                // CSN high, terminate SPI communication  CSN¸ß£¬ÖÕÖ¹SPIÍ¨ÐÅ
 208   1        
 209   1        return(reg_val);        // return register value          ·µ»Ø¼Ä´æÆ÷Öµ
 210   1      }
 211          /****************************************************************************************************/
 212          /*¹¦ÄÜ£ºNRF24L01¶ÁÐ´¼Ä´æÆ÷º¯Êý
 213          /****************************************************************************************************/
 214          uint SPI_RW_Reg(uchar reg, uchar value)
 215          {
 216   1        uint status;
 217   1        
 218   1        CSN = 0;                   // CSN low, init SPI transaction   CSNÖÃµÍ ½øÈëSPIÍ¨ÐÅ
 219   1        status = SPI_RW(reg);      // select register         Ñ¡Ôñ¼Ä´æÆ÷
 220   1        SPI_RW(value);             // ..and write value to it..     ²¢½«ÆäÐ´ÈëÖµ
 221   1        CSN = 1;                   // CSN high again          CSNÔÙ¸ß                                 
 222   1        return(status);            // return nRF24L01 status uchar    ·µ»ØnRF24L01×´Ì¬uchar
 223   1      }
 224          /****************************************************************************************************/
 225          /*º¯Êý£ºuint SPI_Read_Buf(uchar reg, uchar *pBuf, uchar uchars)
 226          /*¹¦ÄÜ: ÓÃÓÚ¶ÁÊý¾Ý£¬reg£ºÎª¼Ä´æÆ÷µØÖ·£¬pBuf£ºÎª´ý¶Á³öÊý¾ÝµØÖ·£¬uchars£º¶Á³öÊý¾ÝµÄ¸öÊý
 227          /****************************************************************************************************/
 228          uint SPI_Read_Buf(uchar reg, uchar *pBuf, uchar uchars)
 229          {
 230   1        uint status,uchar_ctr;
 231   1        
 232   1        CSN = 0;                      // Set CSN low, init SPI tranaction  CSNÖÃµÍ ½øÈëSPIÍ¨ÐÅ
 233   1        status = SPI_RW(reg);         // Select register to write to and read status uchar Ñ¡Ôñ¼Ä´æÆ÷Ð´ÈëºÍ¶ÁÈ¡×´
             -Ì¬uCHAR  Ð´ÈëÒª¶ÁÈ¡µÄ¼Ä´æÆ÷µØÖ·
C51 COMPILER V9.00   STC15NRFRE_2                                                          11/15/2018 21:18:15 PAGE 5   

 234   1        
 235   1        for(uchar_ctr=0;uchar_ctr<uchars;uchar_ctr++)
 236   1          pBuf[uchar_ctr] = SPI_RW(0);    //
 237   1        
 238   1        CSN = 1;                           
 239   1        
 240   1        return(status);                    // return nRF24L01 status uchar
 241   1      }
 242          /*********************************************************************************************************
 243          /*º¯Êý£ºuint SPI_Write_Buf(uchar reg, uchar *pBuf, uchar uchars)
 244          /*¹¦ÄÜ: ÓÃÓÚÐ´Êý¾Ý£ºÎª¼Ä´æÆ÷µØÖ·£¬pBuf£ºÎª´ýÐ´ÈëÊý¾ÝµØÖ·£¬uchars£ºÐ´ÈëÊý¾ÝµÄ¸öÊý
 245          /*********************************************************************************************************
             -/
 246          uint SPI_Write_Buf(uchar reg, uchar *pBuf, uchar uchars)
 247          {
 248   1        uint status,uchar_ctr;
 249   1        
 250   1        CSN = 0;            //SPIÊ¹ÄÜ      
 251   1        status = SPI_RW(reg);   
 252   1        for(uchar_ctr=0; uchar_ctr<uchars; uchar_ctr++) //
 253   1          SPI_RW(*pBuf++);
 254   1        CSN = 1;           //¹Ø±ÕSPI
 255   1        return(status);    //
 256   1      }
 257          /****************************************************************************************************/
 258          /*º¯Êý£ºvoid SetRX_Mode(void)
 259          /*¹¦ÄÜ£ºÊý¾Ý½ÓÊÕÅäÖÃ
 260          /****************************************************************************************************/
 261          void SetRX_Mode(void)
 262          {
 263   1        CE=0;
 264   1        SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);     // IRQÊÕ·¢Íê³ÉÖÐ¶ÏÏìÓ¦£¬16Î»CRC £¬Ö÷½ÓÊÕ
 265   1        CE = 1;
 266   1        inerDelay_us(130);
 267   1      }
 268          /****************************************************************************************************/
 269          /*º¯Êý£ºvoid SetTX_Mode(void)
 270          /*¹¦ÄÜ£ºÊý¾Ý·¢ËÍÅäÖÃ
 271          /****************************************************************************************************/
 272          void SetTX_Mode(void)
 273          {
 274   1        CE=0;
 275   1        SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);     // IRQÊÕ·¢Íê³ÉÖÐ¶ÏÏìÓ¦£¬16Î»CRC £¬Ö÷½ÓÊÕ
 276   1        CE = 1;
 277   1        inerDelay_us(200);
 278   1      }
 279          /******************************************************************************************************/
 280          /*º¯Êý£ºunsigned char nRF24L01_RxPacket(unsigned char* rx_buf)
 281          /*¹¦ÄÜ£ºÊý¾Ý¶ÁÈ¡ºó·ÅÈçrx_buf½ÓÊÕ»º³åÇøÖÐ
 282          /******************************************************************************************************/
 283          unsigned char nRF24L01_RxPacket(unsigned char* rx_buf)
 284          {
 285   1          unsigned char revale=0;
 286   1        sta=SPI_Read(STATUS);   // ¶ÁÈ¡×´Ì¬¼Ä´æÆäÀ´ÅÐ¶ÏÊý¾Ý½ÓÊÕ×´¿ö
 287   1        if(RX_DR)         // ÅÐ¶ÏÊÇ·ñ½ÓÊÕµ½Êý¾Ý
 288   1        {
 289   2             CE = 0;        //SPIÊ¹ÄÜ
 290   2           SPI_Read_Buf(RD_RX_PLOAD,rx_buf,TX_PLOAD_WIDTH);// read receive payload from RX_FIFO buffer  ´ÓRXXFIFO»º
             -³åÆ÷¶ÁÈ¡½ÓÊÕÓÐÐ§ÔØºÉ
 291   2           revale =1;       //¶ÁÈ¡Êý¾ÝÍê³É±êÖ¾
 292   2        }
 293   1        SPI_RW_Reg(WRITE_REG+STATUS,sta);           //½ÓÊÕµ½Êý¾ÝºóRX_DR,TX_DS,MAX_PT¶¼ÖÃ¸ßÎª1£¬Í¨¹ýÐ´1À´Çå³þÖÐ¶Ï±êÖ¾
C51 COMPILER V9.00   STC15NRFRE_2                                                          11/15/2018 21:18:15 PAGE 6   

 294   1        return revale;
 295   1      }
 296          /*********************************************************************************************************
             -**
 297          /*º¯Êý£ºvoid nRF24L01_TxPacket(unsigned char * tx_buf)
 298          /*¹¦ÄÜ£º·¢ËÍ tx_bufÖÐÊý¾Ý
 299          /*********************************************************************************************************
             -*/
 300          
 301          void nRF24L01_TxPacket(unsigned char * tx_buf)
 302          {
 303   1        CE=0;         //StandBy IÄ£Ê½
 304   1        SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, RX_ADDRESS, RX_ADR_WIDTH); // ×°ÔØ½ÓÊÕ¶ËµØÖ·
 305   1        SPI_Write_Buf(WR_TX_PLOAD, tx_buf, TX_PLOAD_WIDTH);         // ×°ÔØÊý¾Ý
 306   1        SPI_RW_Reg(WRITE_REG + CONFIG, 0x0e);                 // IRQÊÕ·¢Íê³ÉÖÐ¶ÏÏìÓ¦£¬16Î»CRC£¬Ö÷·¢ËÍ
 307   1        CE=1;         //ÖÃ¸ßCE£¬¼¤·¢Êý¾Ý·¢ËÍ
 308   1        inerDelay_us(10);
 309   1      }
 310          
 311          
 312          ///******* ÖÐ¶Ï³õÊ¼»¯  ******/
 313          //void init_com(void)
 314          //{
 315          //    TMOD=0x20;            //¶¨Ê±Æ÷1,8Î»×Ô¶¯ÖØ
 316          //  TH1=0xfd;
 317          //  TL1=0xfd;
 318          //  TR1=1;
 319          //  REN=1;              //ÔÊÐí´®¿ÚÖÐ¶Ï
 320          //  SM0=0;              //ÉèÖÃ´®¿Ú¹¤×÷·½Ê½Îª1
 321          //  SM1=1;
 322          //  EA=1;             //¿ª×ÜÖÐ¶Ï
 323          //  ES=1; 
 324          //}             
 325          //void SendByte(unsigned char dat)     //·¢ËÍÒ»¸ö×Ö½ÚµÄÊý¾Ý
 326          //{
 327          //   SBUF = dat;
 328          //   while(!TI);
 329          //      TI = 0;
 330          //}
 331          //void SendStr(unsigned char *s)      //·¢ËÍÒ»¸ö×Ö·û´®µÄÊý¾Ý
 332          //{
 333          //   while(*s!='\0')            // \0 ±íÊ¾×Ö·û´®½áÊø±êÖ¾£¬
 334          //                            //Í¨¹ý¼ì²âÊÇ·ñ×Ö·û´®Ä©Î²
 335          //   {
 336          //      SendByte(*s);
 337          //      s++;
 338          //   }
 339          //}
 340          void uart1(void)
 341          {
 342   1        P0M0 = 0x00;
 343   1          P0M1 = 0x00;
 344   1          P1M0 = 0x00;
 345   1          P1M1 = 0x00;
 346   1          P2M0 = 0x00;
 347   1          P2M1 = 0x00;
 348   1          P3M0 = 0x00;
 349   1          P3M1 = 0x00;
 350   1          P4M0 = 0x00;
 351   1          P4M1 = 0x00;
 352   1          P5M0 = 0x00;
 353   1          P5M1 = 0x00;
C51 COMPILER V9.00   STC15NRFRE_2                                                          11/15/2018 21:18:15 PAGE 7   

 354   1          P6M0 = 0x00;
 355   1          P6M1 = 0x00;
 356   1          P7M0 = 0x00;
 357   1          P7M1 = 0x00;
 358   1      
 359   1          ACC = P_SW1;
 360   1          ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
 361   1          P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
 362   1      
 363   1        #if (PARITYBIT == NONE_PARITY)
                  SCON = 0x50;                //8Î»¿É±ä²¨ÌØÂÊ
              #elif (PARITYBIT == ODD_PARITY) || (PARITYBIT == EVEN_PARITY) || (PARITYBIT == MARK_PARITY)
 366   1          SCON = 0xda;                //9Î»¿É±ä²¨ÌØÂÊ,Ð£ÑéÎ»³õÊ¼Îª1
 367   1      #elif (PARITYBIT == SPACE_PARITY)
                  SCON = 0xd2;                //9Î»¿É±ä²¨ÌØÂÊ,Ð£ÑéÎ»³õÊ¼Îª0
              #endif
 370   1      
 371   1          AUXR = 0x40;                //¶¨Ê±Æ÷1Îª1TÄ£Ê½
 372   1          TMOD = 0x00;                //¶¨Ê±Æ÷1ÎªÄ£Ê½0(16Î»×Ô¶¯ÖØÔØ)
 373   1          TL1 = (65536 - (FOSC/4/BAUD));   //ÉèÖÃ²¨ÌØÂÊÖØ×°Öµ
 374   1          TH1 = (65536 - (FOSC/4/BAUD))>>8;
 375   1          TR1 = 1;                    //¶¨Ê±Æ÷1¿ªÊ¼Æô¶¯
 376   1          ES = 1;                     //Ê¹ÄÜ´®¿ÚÖÐ¶Ï
 377   1          EA = 1;
 378   1      }
 379           /********************************************/
 380          /* º¯Êý¹¦ÄÜ£º¼ì²â24L01ÊÇ·ñ´æÔÚ */
 381          /* ·µ»ØÖµ£» 1 ´æÔÚ */
 382          /* 2 ²»´æÔÚ */
 383          /********************************************/
 384          uchar NRF24L01_Check(void)
 385          {
 386   1      int NRF_CE=0;
 387   1      uchar check_in_buf[5]={0x11,0x22,0x33,0x44,0x55};
 388   1      uchar check_out_buf[5]={0x00};
 389   1      //SendStr("check Init\r\n");
 390   1      
 391   1      
 392   1      SPI_Write_Buf(WRITE_REG+TX_ADDR, check_in_buf, 5);
 393   1      
 394   1      SPI_Read_Buf(READ_REG+TX_ADDR, check_out_buf, 5);
 395   1      
 396   1      if((check_out_buf[0] == 0x11)&&\
 397   1      (check_out_buf[1] == 0x22)&&\
 398   1      (check_out_buf[2] == 0x33)&&\
 399   1      (check_out_buf[3] == 0x44)&&\
 400   1      (check_out_buf[4] == 0x55))return 1;
 401   1      else return 2;
 402   1      }
 403          //************************************Ö÷º¯Êý************************************************************
 404          void main(void)
 405          {
 406   1        uchar temp[]={"001"};
 407   1        uchar a;  //NRFÄ£¿éÊÇ·ñ´æÔÚ±êÖ¾Î»
 408   1        uchar i;
 409   1        uchar RxBuf[2];         //¶¨Òå½ÓÊÕÊý¾ÝµÄÊý×é
 410   1        init_NRF24L01();          //NRF³õÊ¼»¯
 411   1        uart1();
 412   1        Init_T4();       //¶¨Ê±Æ÷³õÊ¼»¯
 413   1        EA = 1;           //´ò¿ªÈ«¾ÖÖÐ¶Ï
 414   1        OLED_Init();      //³õÊ¼»¯OLED  
 415   1        OLED_Clear(); 
C51 COMPILER V9.00   STC15NRFRE_2                                                          11/15/2018 21:18:15 PAGE 8   

 416   1        
 417   1        
 418   1        a=NRF24L01_Check();//¼ì²âNRF±êÖ¾Î»£¬NRF´æÔÚled1ºÍled3ÁÁ£¬·ñÔòled1,2ÁÁ¡£
 419   1        if(a == 1){
 420   2              led0 = 0;
 421   2              led3 =0;
 422   2            }
 423   1        else if(a == 2){
 424   2              led1=0;
 425   2              led2=0;     
 426   2            }
 427   1        else{
 428   2              led0=0;led1=0;led2=0;led3=0;
 429   2            }
 430   1        Delay(6000);
 431   1        
 432   1        
 433   1        
 434   1        while(1)
 435   1        {
 436   2          unsigned char TxBuf[20]={0x36,0x36};    //½«Òª·¢ËÍµÄÊý¾Ý·ÅÔÚÊý×éÖÐ
 437   2          init_NRF24L01();
 438   2          SetRX_Mode();   //ÎÞ°´¼ü°´ÏÂÎª½ÓÊÜÄ£Ê½
 439   2          //SetTX_Mode();   //ÓÐ°´¼ü°´ÏÂÎª·¢ËÍÄ£Ê½
 440   2          nRF24L01_RxPacket(RxBuf);
 441   2          
 442   2          OLED_ShowCHinese(0,0,0);//ÁÙ
 443   2          OLED_ShowCHinese(18,0,1);//´ó
 444   2          OLED_ShowCHinese(36,0,2);//Îï
 445   2          OLED_ShowCHinese(54,0,3);//Áª
 446   2          OLED_ShowCHinese(72,0,4);//Êµ
 447   2          OLED_ShowCHinese(90,0,5);//Ñé
 448   2          OLED_ShowCHinese(108,0,6);//ÊÒ
 449   2          
 450   2          /*OLED_ShowCHinese(0,3,11);//ÎÂ
 451   2          OLED_ShowCHinese(18,3,17);//Êª
 452   2          OLED_ShowCHinese(36,3,12);//¶È
 453   2          OLED_ShowCHinese(54,3,13);//²É
 454   2          OLED_ShowCHinese(72,3,14);//¼¯
 455   2          OLED_ShowCHinese(90,3,15);//½Ú
 456   2          OLED_ShowCHinese(108,3,16);//µã
 457   2          OLED_ShowString(20,6,temp);
 458   2          */
 459   2          OLED_ShowCHinese(0,3,13);//×¡
 460   2          OLED_ShowCHinese(18,3,14);//»§
 461   2          OLED_ShowString(36,3,temp);//001
 462   2          if(flag1 == 1)
 463   2          {
 464   3            flag1 =0;   //¸´Î»
 465   3            speak = !speak;  //·äÃùÆ÷°´ÏÂÏì£¬ÔÚ°´ÏÂ²»Ïì
 466   3            init_NRF24L01_Send();
 467   3            SetTX_Mode();   //ÓÐ°´¼ü°´ÏÂÎª·¢ËÍÄ£Ê½
 468   3            nRF24L01_TxPacket(TxBuf);       //·¢ËÍÊý¾Ý
 469   3            //P0=SPI_Read(STATUS);          //¶Á×´Ì¬¼Ä´æÆ÷µÄÖµ  Èç¹ûÊý¾Ý³É¹¦·¢ËÍ£¬ÄÇÃ´STATUSµÄÖµÓ¦¸ÃÎª0x2e
 470   3            SPI_RW_Reg(WRITE_REG+STATUS,0XFF);    //Çå×´Ì¬¼Ä´æÆ÷
 471   3            Delay(6000);
 472   3            speak =1;               //¹Ø±Õ·äÃùÆ÷
 473   3        
 474   3          }
 475   2          
 476   2          
 477   2          
C51 COMPILER V9.00   STC15NRFRE_2                                                          11/15/2018 21:18:15 PAGE 9   

 478   2      //ÈýÖÖ´®¿Ú·¢ËÍ·½Ê½
 479   2          if(IRQ == 0)  //µ¥Æ¬»úÍ¨¹ý¹Û²ìËüµÄIRQÒý½Å£¬¾Í¿ÉÒÔÖªµÀÊÇ·ñ½ÓÊÕµ½ÁËÊý¾Ý£¬IRQÎªµÍµçÆ½£¬ËµÃ÷½ÓÊÕµ½ÁËÊý¾Ý
 480   2          {
 481   3            OLED_ShowCHinese(36,6,15);//¿ª
 482   3            OLED_ShowCHinese(54,6,16);//Ëø
 483   3            nRF24L01_RxPacket(RxBuf);
 484   3            Delay(600);
 485   3             for(i = 0;i < 2;i++)       //Í¨¹ý´®¿Ú¶Á³öÊý¾Ý
 486   3              SendData(RxBuf[i]);
 487   3            Delay(6000);
 488   3          }
 489   2          else
 490   2          {
 491   3            
 492   3          }
 493   2          /*
 494   2          /////////////////////////////////////////////////////////////////////////////////
 495   2            if(nRF24L01_RxPacket(RxBuf))      //Èô·µ»Ø 1  ËµÃ÷Êý¾Ý½ÓÊÕ³É¹¦
 496   2          {
 497   2           //    led2= 0;
 498   2             Delay(600);
 499   2             for(i = 0;i < 2;i++)       //Í¨¹ý´®¿Ú¶Á³öÊý¾Ý
 500   2              SendData(RxBuf[i]); 
 501   2      //       SendString(RxBuf[20]);
 502   2          }
 503   2          else
 504   2          {
 505   2              //led2 = 1;
 506   2              Delay(60);
 507   2          }
 508   2          
 509   2      /////////////////////////////////////////////////////////////////////////////////////////
 510   2          nRF24L01_RxPacket(RxBuf);       //½ÓÊÕÊý¾Ý
 511   2          c = SPI_Read(STATUS);         //Í¨¹ý¶ÁÈ¡STATUSµÄÖµÀ´ÅÐ¶ÏÊÇÄÄ¸öÊÂ¼þ´¥·¢ÁËÖÐ¶Ï
 512   2          if(c == 0x40)                         //²é¿´ÊÇ·ñ½ÓÊÕ³É¹¦     Èç¹ûÊý¾Ý³É¹¦½ÓÊÕ£¬ÄÇÃ´STATUSµÄÖµÓ¦¸ÃÎª0x40
 513   2          {
 514   2             
 515   2             nRF24L01_RxPacket(RxBuf);
 516   2             Delay(600);
 517   2             for(i = 0;i < 2;i++)       //Í¨¹ý´®¿Ú¶Á³öÊý¾Ý
 518   2              SendData(RxBuf[i]);
 519   2             Delay(6000);     
 520   2          }
 521   2          else
 522   2          {
 523   2             
 524   2             Delay(60);
 525   2          }*/
 526   2        }
 527   1        
 528   1        
 529   1      }
 530          
 531          
 532          /*----------------------------
 533          UART ÖÐ¶Ï·þÎñ³ÌÐò
 534          -----------------------------*/
 535          void Uart() interrupt 4 using 1
 536          {
 537   1          if (RI)
 538   1          {
 539   2              RI = 0;                 //Çå³ýRIÎ»
C51 COMPILER V9.00   STC15NRFRE_2                                                          11/15/2018 21:18:15 PAGE 10  

 540   2              P0 = SBUF;              //P0ÏÔÊ¾´®¿ÚÊý¾Ý
 541   2              P22 = RB8;              //P2.2ÏÔÊ¾Ð£ÑéÎ»
 542   2          }
 543   1          if (TI)
 544   1          {
 545   2              TI = 0;                 //Çå³ýTIÎ»
 546   2              busy = 0;               //ÇåÃ¦±êÖ¾
 547   2          }
 548   1      }
 549          
 550          /*----------------------------
 551          ·¢ËÍ´®¿ÚÊý¾Ý
 552          ----------------------------*/
 553          void SendData(BYTE dat)
 554          {
 555   1          while (busy);               //µÈ´ýÇ°ÃæµÄÊý¾Ý·¢ËÍÍê³É
 556   1          ACC = dat;                  //»ñÈ¡Ð£ÑéÎ»P (PSW.0)
 557   1          if (P)                      //¸ù¾ÝPÀ´ÉèÖÃÐ£ÑéÎ»
 558   1          {
 559   2      #if (PARITYBIT == ODD_PARITY)
                      TB8 = 0;                //ÉèÖÃÐ£ÑéÎ»Îª0
              #elif (PARITYBIT == EVEN_PARITY)
 562   2              TB8 = 1;                //ÉèÖÃÐ£ÑéÎ»Îª1
 563   2      #endif
 564   2          }
 565   1          else
 566   1          {
 567   2      #if (PARITYBIT == ODD_PARITY)
                      TB8 = 1;                //ÉèÖÃÐ£ÑéÎ»Îª1
              #elif (PARITYBIT == EVEN_PARITY)
 570   2              TB8 = 0;                //ÉèÖÃÐ£ÑéÎ»Îª0
 571   2      #endif
 572   2          }
 573   1          busy = 1;
 574   1          SBUF = ACC;                 //Ð´Êý¾Ýµ½UARTÊý¾Ý¼Ä´æÆ÷
 575   1      }
 576          
 577          /*----------------------------
 578          ·¢ËÍ×Ö·û´®
 579          ----------------------------*/
 580          void SendString(char *s)
 581          {
 582   1          while (*s)                  //¼ì²â×Ö·û´®½áÊø±êÖ¾
 583   1          {
 584   2              SendData(*s++);         //·¢ËÍµ±Ç°×Ö·û
 585   2          }
 586   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1017    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13      58
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
